#### 一、let命令

##### 1、作用范围

用let声明变量，只在它所在的代码块有效：适用于for循环

#####2、不存在变量提升

声明的变量必须在声明之后使用，否则就会报错ReferenceError

#####3、暂时性死区

凡是区块中存在let和const命令，这个区块对这些声明的变量，一开始就形成封闭作用域，在这之前使用，就报错

简而言之：在let声明变量之前，该变量都是不可用的，称为暂时性死区（temporal dead zone ：TDZ）

本质：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有它声明的代码出现之后，才可以获取和使用。

##### 4、不允许在相同作用域内重复声明一个变量

```js
// 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}
```

故而不能在函数内部重新声明形参

#### 二、const命令

##### 1、基本用法

- const声明一个只读的常量，一旦声明，常量的值就不能改变
- 声明时必须立刻赋值，否则报错
- 与let相似，只在声明所在的块级作用域内有效
- 在声明之前，同样的不可调用
- 不可重复声明

注意：const声明的变量作为一个地址，不是指向的值不可以改变，而是指向不可以改变。当用const声明一个数组的时候，可以添加属性，但不能将另一个数组赋值给它。如果真的想将对象冻结，应该用object.freeze().

```js
const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
```

#### 三、ES6声明变量的六种方法

ES5两种：var、function

ES6添加：let 、const、import、class

#### 四、顶层对象的属性

ES5中：顶层对象的属性（window.a）和全局变量（a）是等价的

缺点：

- 不利于模块化编程
- 误操作创建全局变量
- 编译时无法报错，只有运行时才能知道

ES6开始，：全局变量将逐步与顶层对象的属性脱钩

```js
var a = 1;
window.a    //1

let b = 1;
window.b    //undefined
```

#### 五、global对象

参见如何取到global对象

[http://es6.ruanyifeng.com/#docs/let#global-对象]()